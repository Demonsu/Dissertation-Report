\chapter{Introduction}

Parser combinators are a set of higher-order functions that accepts several parser as input and then return a parser as output. In this context, a parser is a function accepting strings as input and returning some structure as output, typically a parse tree or a set of indices representing locations in the string where parsing stopped successfully. Parser combinators enable a recursive descendent parsing strategy that facilitates modular piecewise construction and testing. This parsing technique is called combinatory parsing.

Parser and Pretty Printer combinators are an alternative to tools used in compiler constructions, such as lex, yacc or antlr. They have the advantage of being a library instead of a code generator tool.

There already are some existing parser combinators libraries in the real world, such as Parsec \cite{Leijen:2002} in Haskell, the standard parser combinators library in Scala and Planck \cite{Planck} in OCaml. Most of them may have totally different structures and design patterns, but they share some common idea, such as both Parsec and Planck are monadic parser combinators. These libraries takes benefic from several extraordinary language features like lazy evaluation and tail-call elimination, so that they may have considerable performance comparing with traditional parsing techniques.

In this project, we will build a parser combinators library in F2J with optimizations based on the language features of F2J. After that we will also create a pretty printer combinators library, which is the reversed procedure of parsing.
